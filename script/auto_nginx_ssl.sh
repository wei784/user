#!/bin/sh

# ==============================================================================
# 脚本名称: auto_nginx_ssl.sh
# 脚本功能: 自动化配置、管理 Nginx 反向代理及 Certbot SSL 证书
# 支持系统: Debian, Ubuntu, Alpine (POSIX sh 兼容)
# 作者: Gemini
# 版本: 2.4
# ==============================================================================

# --- 全局变量和颜色定义 ---
CONF_FILE="/etc/auto_nginx_ssl.conf" # 用于存储上次使用的邮箱

if tput setaf 1 > /dev/null 2>&1; then
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    NC=$(tput sgr0)
else
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
fi

# --- 辅助函数 ---
print_info() { printf '%b\n' "${BLUE}[INFO] $1${NC}"; }
print_success() { printf '%b\n' "${GREEN}[SUCCESS] $1${NC}"; }
print_warning() { printf '%b\n' "${YELLOW}[WARNING] $1${NC}"; }
print_error() { printf '%b\n' "${RED}[ERROR] $1${NC}" >&2; }
command_exists() { command -v "$1" >/dev/null 2>&1; }

# --- 初始化和环境检查 ---
check_privileges() {
    if [ "$(id -u)" -ne 0 ]; then
        print_error "此脚本需要以 root 用户或使用 sudo 权限运行。"
        exit 1
    fi
}

detect_os() {
    if [ -f /etc/os-release ]; then . /etc/os-release; OS_ID=$ID;
    elif type lsb_release >/dev/null 2>&1; then OS_ID=$(lsb_release -si | tr '[:upper:]' '[:lower:]');
    elif [ -f /etc/debian_version ]; then OS_ID="debian";
    elif [ -f /etc/alpine-release ]; then OS_ID="alpine";
    else OS_ID=$(uname -s); fi

    case "$OS_ID" in
        debian|ubuntu) OS_TYPE="debian"; PKG_MANAGER="apt-get"; NGINX_SERVICE="nginx";;
        alpine) OS_TYPE="alpine"; PKG_MANAGER="apk"; NGINX_SERVICE="nginx";;
        *) print_error "不支持的操作系统: $OS_ID"; exit 1;;
    esac
}

# 确保存在一个默认的 SSL 服务器来处理未知/暂停的域名
ensure_default_ssl_server() {
    default_conf_path="/etc/nginx/conf.d/000-default-ssl-reject.conf"
    if [ -f "$default_conf_path" ]; then return 0; fi
    
    print_info "正在配置 Nginx 默认 SSL '黑洞'服务器..."
    cert_path=""; key_path=""
    
    if [ -f /etc/ssl/certs/ssl-cert-snakeoil.pem ] && [ -f /etc/ssl/private/ssl-cert-snakeoil.key ]; then
        cert_path="/etc/ssl/certs/ssl-cert-snakeoil.pem"; key_path="/etc/ssl/private/ssl-cert-snakeoil.key"
        print_info "找到 snakeoil 证书，将用其作为默认证书。"
    else
        print_warning "未找到 snakeoil 证书，正在生成一个临时的自签名证书..."
        if ! command_exists openssl; then
            print_warning "执行此操作需要 openssl，请先安装。"; return 1
        fi
        dummy_ssl_dir="/etc/nginx/ssl"; mkdir -p "$dummy_ssl_dir"
        cert_path="$dummy_ssl_dir/default.pem"; key_path="$dummy_ssl_dir/default.key"
        openssl req -x509 -nodes -newkey rsa:2048 -days 3650 \
            -keyout "$key_path" -out "$cert_path" -subj "/CN=localhost" >/dev/null 2>&1
        print_success "已成功生成自签名证书。"
    fi

    cat > "$default_conf_path" << EOF
# Auto-generated by auto_nginx_ssl.sh
# Catches all SSL requests for unknown/suspended server names and closes the connection.
server {
    listen 443 ssl default_server;
    listen [::]:443 ssl default_server;
    server_name _;
    ssl_certificate ${cert_path};
    ssl_certificate_key ${key_path};
    return 444;
}
EOF
    print_success "已创建默认 SSL '黑洞'服务器配置。"
    if ! nginx -t >/dev/null 2>&1; then
        print_error "为默认服务器生成的 Nginx 配置无效，请检查。"
        rm "$default_conf_path"
    fi
}


# --- 功能一: 创建新配置 ---
create_new_proxy() {
    install_dependencies
    get_user_input
    request_ssl_certificate
    configure_nginx
    finalize_setup
    
    printf '\n'; print_success "所有操作已成功完成!"
    printf '%b\n' "-----------------------------------------------------"
    printf '%b\n' "您的网站 ${YELLOW}${DOMAIN}${NC} 现已配置完成并通过 HTTPS 访问。"
    printf '%b\n' "Nginx 将流量反向代理到: ${YELLOW}${PROXY_PASS}${NC}"
    if [ "$OS_TYPE" = "debian" ]; then
        printf '%b\n' "Nginx 配置文件位于: ${YELLOW}/etc/nginx/sites-available/${DOMAIN}.conf${NC}"
    else
        printf '%b\n' "Nginx 配置文件位于: ${YELLOW}/etc/nginx/http.d/${DOMAIN}.conf${NC}"
    fi
    printf '%b\n' "SSL 证书文件位于: ${YELLOW}/etc/letsencrypt/live/${DOMAIN}/${NC}"
    printf '%b\n' "-----------------------------------------------------"; printf '\n'
}

install_dependencies() {
    print_info "正在检查并安装依赖..."
    packages_to_install=""
    required_commands="nginx certbot curl openssl"
    if [ "$OS_TYPE" = "debian" ]; then
        for cmd in $required_commands; do
            if ! command_exists "$cmd"; then
                case "$cmd" in
                    nginx) packages_to_install="$packages_to_install nginx" ;;
                    certbot) packages_to_install="$packages_to_install certbot python3-certbot-nginx" ;;
                    curl) packages_to_install="$packages_to_install curl" ;;
                    openssl) packages_to_install="$packages_to_install openssl" ;;
                esac
            fi
        done
    elif [ "$OS_TYPE" = "alpine" ]; then
        for cmd in $required_commands; do
            if ! command_exists "$cmd"; then
                packages_to_install="$packages_to_install $cmd"
            fi
        done
    fi

    packages_to_install=$(echo "$packages_to_install" | sed 's/^ *//')
    if [ -n "$packages_to_install" ]; then
        print_info "以下依赖将会被安装: $packages_to_install"
        if [ "$OS_TYPE" = "debian" ]; then
            $PKG_MANAGER update -y || print_error "更新软件包列表失败。"
            # shellcheck disable=SC2086
            $PKG_MANAGER install -y $packages_to_install || print_error "安装依赖包失败。"
        else
            $PKG_MANAGER update || print_error "更新软件包列表失败。"
            # shellcheck disable=SC2086
            $PKG_MANAGER add $packages_to_install || print_error "安装依赖包失败。"
        fi
    else
        print_success "所有依赖项均已安装。"
    fi
}

get_user_input() {
    print_info "请输入以下配置信息:"
    while true; do
        printf "请输入您的域名 (例如: sub.yourdomain.com): "; read -r DOMAIN
        if echo "$DOMAIN" | grep -qE '^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'; then
            resolved_ip=$(curl -s "https://dns.google/resolve?name=$DOMAIN&type=A" | grep -o '"data":"[^"]*' | head -n1 | cut -d'"' -f4)
            server_ip=$(curl -s ifconfig.me)
            if [ "$resolved_ip" = "$server_ip" ]; then
                print_success "域名 ($DOMAIN) 已成功解析到本机 IP ($server_ip)。"; break
            else
                print_warning "域名 ($DOMAIN) 解析的 IP ($resolved_ip) 与本机 IP ($server_ip) 不匹配。"
                printf "是否继续? (y/n): "; read -r choice
                case "$choice" in [Yy]) break ;; esac
            fi
        else print_warning "域名格式无效，请重新输入。"; fi
    done
    while true; do
        printf "请选择反向代理目标的协议 [http/https] (默认: http): "; read -r protocol; protocol=${protocol:-http}
        if [ "$protocol" = "http" ] || [ "$protocol" = "https" ]; then break; else print_warning "输入无效，请输入 http 或 https。"; fi
    done
    while true; do
        printf "请输入反向代理的目标地址 (例如: 127.0.0.1:8080 或仅输入端口 8080): "; read -r address
        
        if [ -z "$address" ]; then
            print_warning "目标地址不能为空，请重新输入。"
            continue
        fi

        original_address="$address"
        if echo "$address" | grep -qE '^[0-9]+$'; then address="127.0.0.1:$address"; fi
        port=$(echo "$address" | sed 's/.*://')
        if ! echo "$port" | grep -qE '^[0-9]+$'; then
            print_warning "地址格式 '$original_address' 无效，未能解析出有效的端口号。"; continue
        fi
        if [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
            print_warning "端口号 '$port' 无效，请输入 1-65535 之间的数字。"; continue
        fi
        if echo "$original_address" | grep -qE '^[0-9]+$'; then
            print_info "检测到仅输入端口，已自动补全为: $address"
        fi
        break
    done
    PROXY_PASS="${protocol}://${address}"; print_info "反向代理目标地址已设置为: ${PROXY_PASS}"
    
    last_email=""; if [ -f "$CONF_FILE" ]; then last_email=$(cat "$CONF_FILE"); fi
    while true; do
        if [ -n "$last_email" ]; then printf "请输入您的邮箱地址 [默认: %s]: " "$last_email"; else printf "请输入您的邮箱地址 (用于 Let's Encrypt 证书通知): "; fi
        read -r EMAIL; EMAIL=${EMAIL:-$last_email}
        if echo "$EMAIL" | grep -qE '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'; then
            echo "$EMAIL" > "$CONF_FILE" || print_warning "无法保存邮箱地址到 $CONF_FILE"; break
        else print_warning "邮箱地址格式无效或为空，请重新输入。"; fi
    done

    TEST_MODE="no"; printf "是否以测试模式运行 Certbot (dry-run)? [y/N] (默认: N): "; read -r test_choice
    case "$test_choice" in [Yy]) TEST_MODE="yes"; print_info "Certbot 将以测试模式 (--dry-run) 运行。";; *) print_info "Certbot 将以生产模式运行。";; esac
}

request_ssl_certificate() {
    print_info "正在为域名 $DOMAIN 申请 SSL 证书..."; dry_run_flag=""
    if [ "$TEST_MODE" = "yes" ]; then dry_run_flag="--dry-run"; print_info "执行 Certbot 测试运行 (dry-run)..."; fi
    print_info "正在临时停止 Nginx 服务..."
    if [ "$OS_TYPE" = "debian" ]; then systemctl stop "$NGINX_SERVICE"; else rc-service "$NGINX_SERVICE" stop; fi
    certbot certonly --standalone $dry_run_flag -d "$DOMAIN" --email "$EMAIL" --agree-tos --no-eff-email -n
    if [ $? -ne 0 ]; then
        if [ "$OS_TYPE" = "debian" ]; then systemctl start "$NGINX_SERVICE"; else rc-service "$NGINX_SERVICE" start; fi
        print_error "SSL 证书申请失败。请检查各项配置。"
    fi
    if [ "$TEST_MODE" = "yes" ]; then
        print_success "Certbot 测试运行成功！"; print_info "请在无测试模式下重新运行脚本以申请真实证书。"
        if [ "$OS_TYPE" = "debian" ]; then systemctl start "$NGINX_SERVICE"; else rc-service "$NGINX_SERVICE" start; fi
        exit 0
    fi
    print_success "SSL 证书已成功申请。"
    renewal_conf="/etc/letsencrypt/renewal/${DOMAIN}.conf"
    if [ -f "$renewal_conf" ]; then
        print_info "正在为证书配置自动续订挂钩..."
        if [ "$OS_TYPE" = "debian" ]; then
            pre_hook_cmd="systemctl stop $NGINX_SERVICE"; post_hook_cmd="systemctl start $NGINX_SERVICE"
        else
            pre_hook_cmd="rc-service $NGINX_SERVICE stop"; post_hook_cmd="rc-service $NGINX_SERVICE start"
        fi
        if ! grep -q -E "^\s*pre_hook" "$renewal_conf"; then sed -i "/\[renewalparams\]/a pre_hook = $pre_hook_cmd" "$renewal_conf"; fi
        if ! grep -q -E "^\s*post_hook" "$renewal_conf"; then sed -i "/\[renewalparams\]/a post_hook = $post_hook_cmd" "$renewal_conf"; fi
        print_success "续订挂钩已成功配置。"
    fi
}

configure_nginx() {
    print_info "正在生成 Nginx 配置文件..."
    if [ "$OS_TYPE" = "debian" ]; then nginx_conf_path="/etc/nginx/sites-available/${DOMAIN}.conf"; else nginx_conf_path="/etc/nginx/http.d/${DOMAIN}.conf"; fi
    cat > "$nginx_conf_path" << EOF
# ${DOMAIN} - Nginx Configuration
# Auto-generated by auto_nginx_ssl.sh
server {
    listen 80; listen [::]:80; server_name ${DOMAIN};
    location /.well-known/acme-challenge/ { root /var/www/html; }
    location / { return 301 https://\$host\$request_uri; }
}
server {
    listen 443 ssl; listen [::]:443 ssl; http2 on; server_name ${DOMAIN};
    ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL_${DOMAIN}:10m;
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
    location / {
        proxy_pass ${PROXY_PASS};
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
EOF
    if [ "$OS_TYPE" = "debian" ]; then
        if [ ! -L "/etc/nginx/sites-enabled/${DOMAIN}.conf" ]; then ln -s "$nginx_conf_path" "/etc/nginx/sites-enabled/"; fi
    fi
    print_success "Nginx 配置文件已生成: ${nginx_conf_path}"; nginx -t || print_error "Nginx 配置测试失败。"
}

finalize_setup() {
    print_info "正在启动 Nginx 服务...";
    if [ "$OS_TYPE" = "debian" ]; then systemctl start "$NGINX_SERVICE"; systemctl enable "$NGINX_SERVICE";
    else rc-service "$NGINX_SERVICE" start; rc-update add "$NGINX_SERVICE" default; fi
    print_success "Nginx 服务已启动。"
    print_info "正在针对新域名 ${DOMAIN} 测试证书自动续期功能...";
    certbot renew --dry-run --cert-name "$DOMAIN"
    if [ $? -ne 0 ]; then
        print_warning "针对 ${DOMAIN} 的续期测试失败。请关注邮箱通知。"
    else
        print_success "证书自动续期配置正常。"
    fi
}

# --- 功能二: 管理已有配置 ---
get_all_proxy_domains() {
    nginx_conf_dir=""; domain_list=""
    if [ "$OS_TYPE" = "debian" ]; then nginx_conf_dir="/etc/nginx/sites-available";
    else nginx_conf_dir="/etc/nginx/http.d"; fi
    
    # shellcheck disable=SC2046
    for conf_file in $(find "$nginx_conf_dir" -type f -name "*.conf"); do
        if grep -q "Auto-generated by auto_nginx_ssl.sh" "$conf_file"; then
            domain=$(basename "$conf_file" .conf)
            case " $domain_list " in *" $domain "*) ;; *) domain_list="$domain_list $domain" ;; esac
        fi
    done
    
    # 在 Alpine 上，额外查找被禁用的文件
    if [ "$OS_TYPE" = "alpine" ]; then
        # shellcheck disable=SC2046
        for conf_file in $(find "$nginx_conf_dir" -type f -name "*.conf.disabled"); do
            if grep -q "Auto-generated by auto_nginx_ssl.sh" "$conf_file"; then
                domain=$(basename "$conf_file" .conf.disabled)
                case " $domain_list " in *" $domain "*) ;; *) domain_list="$domain_list $domain" ;; esac
            fi
        done
    fi

    echo "$domain_list" | sed 's/^ *//'
}

manage_proxies_menu() {
    while true; do
        clear; print_info "管理已有的反向代理配置"
        domain_list=$(get_all_proxy_domains)
        if [ -z "$domain_list" ]; then
            printf "\n没有找到由本脚本创建的配置。\n\n按 Enter 键返回主菜单..."; read -r _; break
        fi
        
        count=0
        for domain in $domain_list; do
            count=$((count + 1))
            status_text=""; is_active=0
            if [ "$OS_TYPE" = "debian" ]; then
                if [ -L "/etc/nginx/sites-enabled/$domain.conf" ]; then is_active=1; fi
            else # Alpine
                if [ -f "/etc/nginx/http.d/$domain.conf" ]; then is_active=1; fi
            fi
            
            if [ "$is_active" -eq 1 ]; then status_text="${GREEN}(运行中)${NC}"; else status_text="${YELLOW}(已暂停)${NC}"; fi
            printf "  %s) %-30s %b\n" "$count" "$domain" "$status_text"
        done

        printf "\n请输入要管理的配置编号 (输入 'B' 或按 Enter 返回主菜单): "; read -r choice
        case "$choice" in
            ""|[Bb]*) break ;;
            *)
                selected_domain=$(echo "$domain_list" | awk -v n="$choice" '{print $n}')
                if [ -n "$selected_domain" ]; then manage_single_proxy_menu "$selected_domain";
                else print_warning "无效的选项 '$choice'。"; sleep 2; fi;;
        esac
    done
}

manage_single_proxy_menu() {
    domain="$1"
    while true; do
        clear; printf "正在管理域名: %b\n" "${YELLOW}$domain${NC}"; printf -- "----------------------------------------\n"
        
        is_active=0; toggle_action_text=""
        if [ "$OS_TYPE" = "debian" ]; then
            if [ -L "/etc/nginx/sites-enabled/$domain.conf" ]; then is_active=1; fi
        else # Alpine
            if [ -f "/etc/nginx/http.d/$domain.conf" ]; then is_active=1; fi
        fi

        if [ "$is_active" -eq 1 ]; then
            printf "当前状态: %b\n\n" "${GREEN}运行中${NC}"; toggle_action_text="暂停"
        else
            printf "当前状态: %b\n\n" "${YELLOW}已暂停${NC}"; toggle_action_text="恢复"
        fi
        
        printf "请选择操作:\n"; printf "  1) %s\n" "$toggle_action_text"
        printf "  2) %b\n" "${RED}删除配置${NC}"; printf "  3) 返回上一级\n"
        printf "请输入选项 [1-3]: "; read -r sub_choice

        case "$sub_choice" in
            1) toggle_proxy_status "$domain" "$is_active";;
            2) delete_proxy "$domain"; break;;
            3) break;;
            *) print_warning "无效的选项。"; sleep 2;;
        esac
    done
}

toggle_proxy_status() {
    domain="$1"; is_active="$2"
    print_info "正在切换 '$domain' 的状态..."
    if [ "$is_active" -eq 1 ]; then # 如果是激活的，则暂停
        if [ "$OS_TYPE" = "debian" ]; then
            rm -f "/etc/nginx/sites-enabled/$domain.conf"
        else
            mv "/etc/nginx/http.d/$domain.conf" "/etc/nginx/http.d/$domain.conf.disabled"
        fi
        print_success "'$domain' 已暂停。"
    else # 如果是暂停的，则恢复
        if [ "$OS_TYPE" = "debian" ]; then
            ln -s "/etc/nginx/sites-available/$domain.conf" "/etc/nginx/sites-enabled/"
        else
            mv "/etc/nginx/http.d/$domain.conf.disabled" "/etc/nginx/http.d/$domain.conf"
        fi
        print_success "'$domain' 已恢复。"
    fi
    print_info "正在重新加载 Nginx 配置..."; nginx -s reload || print_error "Nginx 重载失败！"
    sleep 2
}

delete_proxy() {
    domain="$1"
    printf "您确定要永久删除 '$domain' 的所有配置吗？(y/N): "; read -r confirm
    case "$confirm" in
        [Yy])
            print_info "正在删除 '$domain'..."
            if [ "$OS_TYPE" = "debian" ]; then
                rm -f "/etc/nginx/sites-enabled/$domain.conf"
                rm -f "/etc/nginx/sites-available/$domain.conf"
            else
                rm -f "/etc/nginx/http.d/$domain.conf"
                rm -f "/etc/nginx/http.d/$domain.conf.disabled" # 同时删除可能存在的禁用文件
            fi
            print_info "Nginx 配置文件已删除。"
            
            if command_exists certbot; then
                print_info "正在删除 SSL 证书..."
                certbot delete --cert-name "$domain" --non-interactive
            fi

            print_info "正在重新加载 Nginx 配置..."; nginx -s reload || print_warning "Nginx 重载失败。"
            print_success "'$domain' 已被彻底删除。"; sleep 2
            ;;
        *) print_info "删除操作已取消。"; sleep 2;;
    esac
}

# --- 脚本主入口 ---
main() {
    check_privileges
    detect_os
    ensure_default_ssl_server # 在主逻辑开始前，确保默认服务器已配置

    while true; do
        clear
        printf '%b\n' "${GREEN}=====================================================${NC}"
        printf '%b\n' "${GREEN}      Nginx & Certbot 一键反代与 SSL 管理脚本      ${NC}"
        printf '%b\n' "${GREEN}=====================================================${NC}"; printf '\n'

        printf "请选择要执行的操作:\n"
        printf "  1) 创建新的反向代理配置\n"
        printf "  2) 管理已有的反代配置\n"
        printf "  3) 退出\n"
        printf "请输入选项 [1-3]: "; read -r choice

        case "$choice" in
            1) create_new_proxy; printf "\n按 Enter 键返回主菜单..."; read -r _;;
            2) manage_proxies_menu;;
            3) print_info "脚本已退出。"; exit 0;;
            *) print_warning "无效的选项。"; sleep 2;;
        esac
    done
}

main

